"use strict";
/// <reference types="jasmine" />
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.adapterFactory = exports.JasmineAdapter = void 0;
const jasmine_1 = __importDefault(require("jasmine"));
const utils_1 = require("@wdio/utils");
const logger_1 = __importDefault(require("@wdio/logger"));
const reporter_1 = __importDefault(require("./reporter"));
const INTERFACES = {
    bdd: ['beforeAll', 'beforeEach', 'it', 'xit', 'fit', 'afterEach', 'afterAll']
};
const TEST_INTERFACES = ['it', 'fit', 'xit'];
const NOOP = function noop() { };
const DEFAULT_TIMEOUT_INTERVAL = 60000;
const log = logger_1.default('@wdio/jasmine-framework');
/**
 * Jasmine 2.x runner
 */
class JasmineAdapter {
    constructor(_cid, _config, _specs, _capabilities, reporter) {
        this._cid = _cid;
        this._config = _config;
        this._specs = _specs;
        this._capabilities = _capabilities;
        this._totalTests = 0;
        this._hookIds = 0;
        this._hasTests = true;
        this._jasmineOpts = Object.assign({
            cleanStack: true
        }, (this._config.jasmineOpts ||
            // @ts-expect-error legacy option
            this._config.jasmineNodeOpts));
        this._reporter = new reporter_1.default(reporter, {
            cid: this._cid,
            specs: this._specs,
            cleanStack: this._jasmineOpts.cleanStack
        });
        this._hasTests = true;
    }
    async init() {
        const self = this;
        this._jrunner = new jasmine_1.default({});
        const { jasmine } = this._jrunner;
        // @ts-ignore outdated
        const jasmineEnv = jasmine.getEnv();
        this._jrunner.projectBaseDir = '';
        // @ts-ignore outdated
        this._jrunner.specDir = '';
        this._jrunner.addSpecFiles(this._specs);
        // @ts-ignore only way to hack timeout into jasmine
        jasmine.DEFAULT_TIMEOUT_INTERVAL = this._jasmineOpts.defaultTimeoutInterval || DEFAULT_TIMEOUT_INTERVAL;
        jasmineEnv.addReporter(this._reporter);
        /**
         * Filter specs to run based on jasmineOpts.grep and jasmineOpts.invert
         */
        jasmineEnv.configure({
            specFilter: this._jasmineOpts.specFilter || this.customSpecFilter.bind(this),
            stopOnSpecFailure: Boolean(this._jasmineOpts.stopOnSpecFailure),
            failSpecWithNoExpectations: Boolean(this._jasmineOpts.failSpecWithNoExpectations),
            failFast: this._jasmineOpts.failFast,
            random: Boolean(this._jasmineOpts.random),
            seed: Boolean(this._jasmineOpts.seed),
            oneFailurePerSpec: Boolean(
            // depcrecated old property
            this._jasmineOpts.stopSpecOnExpectationFailure ||
                this._jasmineOpts.oneFailurePerSpec)
        });
        /**
         * enable expectHandler
         */
        jasmine.Spec.prototype.addExpectationResult = this.getExpectationResultHandler(jasmine);
        const hookArgsFn = (context) => [{ ...(self._lastTest || {}) }, context];
        const emitHookEvent = (fnName, eventType) => (_test, _context, { error } = {}) => {
            const title = `"${fnName === 'beforeAll' ? 'before' : 'after'} all" hook`;
            const hook = {
                id: '',
                start: new Date(),
                type: 'hook',
                description: title,
                fullName: title,
                duration: null,
                properties: {},
                ...(error ? { error } : {})
            };
            this._reporter.emit('hook:' + eventType, hook);
        };
        /**
         * wrap commands with wdio-sync
         */
        INTERFACES['bdd'].forEach((fnName) => {
            const isTest = TEST_INTERFACES.includes(fnName);
            const beforeHook = [...this._config.beforeHook];
            const afterHook = [...this._config.afterHook];
            /**
             * add beforeAll and afterAll hooks to reporter
             */
            if (fnName.includes('All')) {
                beforeHook.push(emitHookEvent(fnName, 'start'));
                afterHook.push(emitHookEvent(fnName, 'end'));
            }
            utils_1.runTestInFiberContext(isTest, isTest ? this._config.beforeTest : beforeHook, hookArgsFn, isTest ? this._config.afterTest : afterHook, hookArgsFn, fnName, this._cid);
        });
        /**
         * for a clean stdout we need to avoid that Jasmine initialises the
         * default reporter
         */
        jasmine_1.default.prototype.configureDefaultReporter = NOOP;
        /**
         * wrap Suite and Spec prototypes to get access to their data
         */
        // @ts-ignore
        let beforeAllMock = jasmine.Suite.prototype.beforeAll;
        // @ts-ignore
        jasmine.Suite.prototype.beforeAll = function (...args) {
            self._lastSpec = this.result;
            beforeAllMock.apply(this, args);
        };
        let executeMock = jasmine.Spec.prototype.execute;
        jasmine.Spec.prototype.execute = function (...args) {
            self._lastTest = this.result;
            // @ts-ignore overwrite existing type
            self._lastTest.start = new Date().getTime();
            executeMock.apply(this, args);
        };
        this._loadFiles();
        /**
         * import and set options for `expect-webdriverio` assertion lib once
         * the framework was initiated so that it can detect the environment
         */
        const { setOptions } = require('expect-webdriverio');
        setOptions({
            wait: this._config.waitforTimeout,
            interval: this._config.waitforInterval, // interval between attempts
        });
        return this;
    }
    _loadFiles() {
        if (!this._jrunner) {
            throw new Error('Jasmine not initiate yet');
        }
        try {
            if (Array.isArray(this._jasmineOpts.requires)) {
                // @ts-ignore outdated types
                this._jrunner.addRequires(this._jasmineOpts.requires);
            }
            if (Array.isArray(this._jasmineOpts.helpers)) {
                // @ts-ignore outdated types
                this._jrunner.addHelperFiles(this._jasmineOpts.helpers);
            }
            // @ts-ignore outdated types
            this._jrunner.loadRequires();
            this._jrunner.loadHelpers();
            this._jrunner.loadSpecs();
            // @ts-ignore outdated types
            this._grep(this._jrunner.env.topSuite());
            this._hasTests = this._totalTests > 0;
        }
        catch (err) {
            log.warn('Unable to load spec files quite likely because they rely on `browser` object that is not fully initialised.\n' +
                '`browser` object has only `capabilities` and some flags like `isMobile`.\n' +
                'Helper files that use other `browser` commands have to be moved to `before` hook.\n' +
                `Spec file(s): ${this._specs.join(',')}\n`, 'Error: ', err);
        }
    }
    _grep(suite) {
        // @ts-ignore outdated types
        suite.children.forEach((child) => {
            if (Array.isArray(child.children)) {
                return this._grep(child);
            }
            if (this.customSpecFilter(child)) {
                this._totalTests++;
            }
        });
    }
    hasTests() {
        return this._hasTests;
    }
    async run() {
        const result = await new Promise((resolve, reject) => {
            if (!this._jrunner) {
                return reject(new Error('Jasmine not initiate yet'));
            }
            this._jrunner.env.beforeAll(this.wrapHook('beforeSuite'));
            this._jrunner.env.afterAll(this.wrapHook('afterSuite'));
            this._jrunner.onComplete(() => resolve(this._reporter.getFailedCount()));
            this._jrunner.execute();
        });
        await utils_1.executeHooksWithArgs('after', this._config.after, [result, this._capabilities, this._specs]);
        return result;
    }
    customSpecFilter(spec) {
        const { grep, invertGrep } = this._jasmineOpts;
        const grepMatch = !grep || spec.getFullName().match(new RegExp(grep)) !== null;
        if (grepMatch === Boolean(invertGrep)) {
            // @ts-ignore outdated types
            spec.pend('grep');
            return false;
        }
        return true;
    }
    /**
     * Hooks which are added as true Jasmine hooks need to call done() to notify async
     */
    wrapHook(hookName) {
        return () => utils_1.executeHooksWithArgs(hookName, this._config[hookName], [this.prepareMessage(hookName)]).catch((e) => {
            log.info(`Error in ${hookName} hook: ${e.stack.slice(7)}`);
        });
    }
    prepareMessage(hookName) {
        var _a, _b;
        const params = { type: hookName };
        switch (hookName) {
            case 'beforeSuite':
            case 'afterSuite':
                params.payload = Object.assign({
                    file: (_a = this._jrunner) === null || _a === void 0 ? void 0 : _a.specFiles[0]
                }, this._lastSpec);
                break;
            case 'beforeTest':
            case 'afterTest':
                params.payload = Object.assign({
                    file: (_b = this._jrunner) === null || _b === void 0 ? void 0 : _b.specFiles[0]
                }, this._lastTest);
                break;
        }
        return this.formatMessage(params);
    }
    formatMessage(params) {
        var _a;
        let message = {
            type: params.type
        };
        if (params.payload) {
            message.title = params.payload.description;
            message.fullName = params.payload.fullName || null;
            message.file = params.payload.file;
            if (params.payload.failedExpectations && params.payload.failedExpectations.length) {
                message.errors = params.payload.failedExpectations;
                message.error = params.payload.failedExpectations[0];
            }
            if (params.payload.id && params.payload.id.startsWith('spec')) {
                message.parent = (_a = this._lastSpec) === null || _a === void 0 ? void 0 : _a.description;
                message.passed = params.payload.failedExpectations.length === 0;
            }
            if (params.type === 'afterTest') {
                message.duration = new Date().getTime() - params.payload.start;
            }
            if (typeof params.payload.duration === 'number') {
                message.duration = params.payload.duration;
            }
        }
        return message;
    }
    getExpectationResultHandler(jasmine) {
        let { expectationResultHandler } = this._jasmineOpts;
        const origHandler = jasmine.Spec.prototype.addExpectationResult;
        if (typeof expectationResultHandler !== 'function') {
            return origHandler;
        }
        return this.expectationResultHandler(origHandler);
    }
    expectationResultHandler(origHandler) {
        const { expectationResultHandler } = this._jasmineOpts;
        return function (passed, data) {
            try {
                expectationResultHandler.call(this, passed, data);
            }
            catch (e) {
                /**
                 * propagate expectationResultHandler error if actual assertion passed
                 * but the custom handler decides to throw
                 */
                if (passed) {
                    passed = false;
                    data = {
                        passed,
                        message: 'expectationResultHandlerError: ' + e.message,
                        error: e
                    };
                }
            }
            return origHandler.call(this, passed, data);
        };
    }
}
exports.JasmineAdapter = JasmineAdapter;
const adapterFactory = {};
exports.adapterFactory = adapterFactory;
adapterFactory.init = async function (...args) {
    // @ts-ignore pass along parameters
    const adapter = new JasmineAdapter(...args);
    const instance = await adapter.init();
    return instance;
};
exports.default = adapterFactory;
__exportStar(require("./types"), exports);
